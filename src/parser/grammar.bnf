# https://jafma.net/software/ll1grammar/

# program ::= listoflines

# listoflines ::= line ENDOFLINE listoflines
# listoflines ::= ε

line ::= LINENUMBER statements

statements ::= statementwithnormsep restofstatementsnorm
statements ::= statementwiththensep restofstatementsthen
# to allow for ": :"
statements ::= restofstatementsnorm

statementwithnormsep ::= statement0
statementwithnormsep ::= statement01
statementwithnormsep ::= statement1
statementwithnormsep ::= statement2
statementwithnormsep ::= statementcons
statementwithnormsep ::= statementgraph
statementwithnormsep ::= statementcass
statementwithnormsep ::= statementflownext
statementwithnormsep ::= statementdeclv
statementwithnormsep ::= statementdefs

statementwiththensep ::= statementflowif

restofstatementsnorm ::= ENDOFSTAT statements
restofstatementsnorm ::= ε

restofstatementsthen ::= THEN statements
# In BASIC, THEN can be followed by stat or by ':' or by nothing.

statement0 ::= COPY
statement0 ::= STOP
statement0 ::= NEW
statement0 ::= CONTINUE
statement0 ::= CLS
statement0 ::= RETURN
# This terminal embeds the comment inside
statement0 ::= REM

statement01 ::= LLIST topleveloptexpr
statement01 ::= LIST topleveloptexpr
statement01 ::= RUN topleveloptexpr
statement01 ::= RANDOMIZE topleveloptexpr
statement01 ::= RESTORE topleveloptexpr
statement01 ::= CLEAR topleveloptexpr

statement1 ::= MERGE toplevelexpr
statement1 ::= INK toplevelexpr
statement1 ::= PAPER toplevelexpr
statement1 ::= FLASH toplevelexpr
statement1 ::= BRIGHT toplevelexpr
statement1 ::= INVERSE toplevelexpr
statement1 ::= OVER toplevelexpr
statement1 ::= BORDER toplevelexpr
statement1 ::= GOTO toplevelexpr
statement1 ::= GOSUB toplevelexpr
statement1 ::= PAUSE toplevelexpr
statement1 ::= CLOSE toplevelexpr

statement2 ::= BEEP toplevelexpr COMMA toplevelexpr
statement2 ::= OUT toplevelexpr COMMA toplevelexpr
statement2 ::= POKE toplevelexpr COMMA toplevelexpr
statement2 ::= OPEN toplevelexpr COMMA toplevelexpr

statementcons ::= LPRINT printseq
statementcons ::= INPUT inputseq
statementcons ::= PRINT printseq

statementgraph ::= PLOT plotseq toplevelexpr COMMA toplevelexpr
statementgraph ::= CIRCLE plotseq toplevelexpr COMMA toplevelexpr COMMA toplevelexpr
statementgraph ::= DRAW plotseq toplevelexpr COMMA toplevelexpr optionaldraw

statementcass ::= VERIFY toplevelexpr filespecextra
statementcass ::= LOAD toplevelexpr filespecextra
statementcass ::= SAVE toplevelexpr filespecextra

statementdeclv ::= DIM VARNAME vardims
statementdeclv ::= LET topvar EQUAL toplevelexpr
statementdeclv ::= READ listofreadvars
statementdeclv ::= FOR VARNAME EQUAL toplevelexpr TO toplevelexpr optionalstep
# Notice that "statementcons" also can include declarations of vars, e.g., in INPUT

statementflownext ::= NEXT VARNAME

statementflowif ::= IF toplevelexpr

statementdefs ::= DEFFN definitionfn
statementdefs ::= DATA listofexprs


# ---------------- STATEMENT: DEF FN

definitionfn ::= VARNAME BEGINPAR funcparms ENDPAR EQUAL toplevelexpr
# funcparms may repeat the same VARNAME and it will be considered different
# (no recursive calls will be made in execution)

funcparms ::= VARNAME restofparms
funcparms ::= ε

restofparms ::= COMMA funcparms
restofparms ::= ε


# ---------------- STATEMENT: FILE MANAGEMENT STATEMENTS

filespecextra ::= DATA VARNAME BEGINPAR ENDPAR
filespecextra ::= CODE filespeccode
filespecextra ::= SCREEN
filespecextra ::= LINE toplevelexpr
filespecextra ::= ε

filespeccode ::= toplevelexpr restoffilespeccode
filespeccode ::= ε

restoffilespeccode ::= COMMA toplevelexpr
restoffilespeccode ::= ε


# ---------------- STATEMENT: PRINT

printseq ::= printitem restofprintseq
printseq ::= printsep printseq
printseq ::= ε

printitem ::= toplevelexpr
printitem ::= printcontrol

restofprintseq ::= printsep printseq
restofprintseq ::= ε

printsep ::= COMMA
printsep ::= APOSTROPHE
printsep ::= SEMICOLON

printcontrol ::= attrcontrol
printcontrol ::= loccontrol
printcontrol ::= streamcontrol

attrcontrol ::= PAPER toplevelexpr
attrcontrol ::= INK toplevelexpr
attrcontrol ::= BRIGHT toplevelexpr
attrcontrol ::= FLASH toplevelexpr
attrcontrol ::= INVERSE toplevelexpr
attrcontrol ::= OVER toplevelexpr

loccontrol ::= AT toplevelexpr COMMA toplevelexpr
loccontrol ::= TAB toplevelexpr

streamcontrol ::= STREAM toplevelexpr


# ---------------- STATEMENT: INPUT

inputseq ::= inputitem restofinputseq
inputseq ::= printsep moreinputseq

moreinputseq ::= inputseq
moreinputseq ::= ε

# expression that cannot begin with a var
inputitem ::= toplevelexprnonvar
# indexed or not
inputitem ::= topvar
inputitem ::= LINE topvar
inputitem ::= printcontrol

optionalinputitem ::= inputitem
optionalinputitem ::= ε

inputseqorempty ::= optionalinputitem restofinputseq

restofinputseq ::= printsep inputseqorempty
restofinputseq ::= ε

# ---------------- STATEMENT: PLOT & DRAW

plotseq ::= plotitems
plotseq ::= ε

plotitems ::= plotitem SEMICOLON restofplotitems

restofplotitems ::= plotitems
restofplotitems ::= ε

plotitem ::= attrcontrol

optionaldraw ::= COMMA toplevelexpr
optionaldraw ::= ε


# ---------------- STATEMENT: READ

listofreadvars ::= topvar restoflistofreadvars

restoflistofreadvars ::= COMMA listofreadvars
restoflistofreadvars ::= ε


# ---------------- STATEMENT: DIM

vardims ::= BEGINPAR dims ENDPAR
# "dims" cannot be empty */

dims ::= toplevelexpr restofdims

restofdims ::= COMMA dims
restofdims ::= ε


#  ---------------- STATEMENT: FOR

optionalstep ::= STEP toplevelexpr
optionalstep ::= ε


# ---------------- VARS IN EXPRESSIONS

topvar ::= var
# To distinguish between vars embedded in an expression and isolated vars as in LET, etc.

var ::= VARNAME optionalseqofindexes
# General use of a variable in an expr.
# A string var may be indexed several times, e.g., 'a$( TO 8)( TO 3)( TO 1)'
# Any var can have several indexes in the first parenthesis (if it is a matrix)
# separated by comma, but only one in each of the following.
# If the variable is an array, it cannot have "TO" slices except in the last index
# of the first parenthesis, as long as it is string; that must be checked out
# besides parsing.
# This grammar cannot check whether VARNAME is not a string but a TO is used
# (error); that must also be done besides parsing.

optionalseqofindexes ::= firstparindexes optionalmoreseqofindexes
optionalseqofindexes ::= ε

optionalmoreseqofindexes ::= moreparindexes optionalmoreseqofindexes
optionalmoreseqofindexes ::= ε

firstparindexes ::= BEGINPAR indexes ENDPAR

moreparindexes ::= BEGINPAR index ENDPAR

indexes ::= indexorslice tailofindexes
indexes ::= ε

index ::= indexorslice
index ::= ε

tailofindexes ::= COMMA indexorslice tailofindexes
tailofindexes ::= ε

indexorslice ::= indexorslice1
indexorslice ::= indexorslice2

indexorslice1 ::= expression restofindexofslice1

indexorslice2 ::= TO restofrestofindexofslice
# Slicing beginning with TO

restofindexofslice1 ::= TO restofrestofindexofslice
restofindexofslice1 ::= ε

restofrestofindexofslice ::= expression
restofrestofindexofslice ::= ε


# ---------------- MID LEVEL: EXPRESSIONS

topleveloptexpr ::= toplevelexpr
topleveloptexpr ::= ε

toplevelexpr ::= expression
# Cannot be nested, unlike expression

toplevelexprnonvar ::= expressionnonvar
# Cannot be nested, unlike expressionnonvar

listofexprs ::= toplevelexpr restoflistofexprs

restoflistofexprs ::= COMMA listofexprs
restoflistofexprs ::= ε

expression ::= highprecexpr restofexpr
# We cannot distinguish between numeric and string expressions in this grammar
# because the DATA statement needs a list of expressions with mixed types
# (numeric / string), and that would make the grammar non-LL(1). Therefore, the
# semantic parsing is in charge of detecting forbidden expressions (operations
# not allowed on numeric or on strings, for instance). */

expressionnonvar ::= highprecexprnonvar restofexpr
#  cannot begin with a var

highprecexpr ::= highprecexprnonvar
highprecexpr ::= var

# Compiled no. embedded in terminal
highprecexprnonvar ::= NUMLIT
# slice/index a str literal
highprecexprnonvar ::= STRINGLIT optionalmoreseqofindexes
# idem
highprecexprnonvar ::= BEGINPAR expression ENDPAR optionalmoreseqofindexes
# unary minus
highprecexprnonvar ::= MINUS highprecexpr
# unary plus
highprecexprnonvar ::= PLUS highprecexpr
highprecexprnonvar ::= FN usrfunctioncall
highprecexprnonvar ::= sysfunctioncall

restofexpr ::= op expression
restofexpr ::= ε

op ::= EXPON
op ::= MULT
op ::= DIV
op ::= PLUS
# binary minus and plus
op ::= MINUS
op ::= EQUAL
op ::= GREAT
op ::= LESS
op ::= GREATEQ
op ::= LESSEQ
op ::= NOTEQ
op ::= AND
op ::= OR

# In the ZX, the sys functions have higher priority than the rest of the
# expression where they are

sysfunctioncall ::= RND
sysfunctioncall ::= PI
sysfunctioncall ::= CODE highprecexpr
sysfunctioncall ::= VAL highprecexpr
sysfunctioncall ::= LEN highprecexpr
sysfunctioncall ::= SIN highprecexpr
sysfunctioncall ::= COS highprecexpr
sysfunctioncall ::= TAN highprecexpr
sysfunctioncall ::= ASN highprecexpr
sysfunctioncall ::= ACS highprecexpr
sysfunctioncall ::= ATN highprecexpr
sysfunctioncall ::= LN highprecexpr
sysfunctioncall ::= EXP highprecexpr
sysfunctioncall ::= INT highprecexpr
sysfunctioncall ::= SQR highprecexpr
sysfunctioncall ::= SGN highprecexpr
sysfunctioncall ::= ABS highprecexpr
sysfunctioncall ::= PEEK highprecexpr
sysfunctioncall ::= IN highprecexpr
sysfunctioncall ::= NOT highprecexpr
sysfunctioncall ::= BIN NUMLIT
sysfunctioncall ::= USR highprecexpr
sysfunctioncall ::= POINT BEGINPAR expression COMMA expression ENDPAR
sysfunctioncall ::= ATTR BEGINPAR expression COMMA expression ENDPAR
sysfunctioncall ::= INKEY
sysfunctioncall ::= SCREEN BEGINPAR expression COMMA expression ENDPAR
sysfunctioncall ::= VAL_STR highprecexpr
sysfunctioncall ::= STR highprecexpr
sysfunctioncall ::= CHR highprecexpr

usrfunctioncall ::= VARNAME BEGINPAR fnoptionallistofexprs ENDPAR

fnoptionallistofexprs ::= fnlistofexprs
fnoptionallistofexprs ::= ε

fnlistofexprs ::= expression fnrestoflistofexprs

fnrestoflistofexprs ::= COMMA fnlistofexprs
fnrestoflistofexprs ::= ε
